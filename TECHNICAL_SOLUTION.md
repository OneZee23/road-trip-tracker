# –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ: Road Trip Tracker iOS

## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ
1. [–û–±—â–∏–π –æ–±–∑–æ—Ä](#–æ–±—â–∏–π-–æ–±–∑–æ—Ä)
2. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è)
3. [–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫](#—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π-—Å—Ç–µ–∫)
4. [–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞](#—Å—Ç—Ä—É–∫—Ç—É—Ä–∞-–ø—Ä–æ–µ–∫—Ç–∞)
5. [–ú–æ–¥—É–ª–∏ –∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã](#–º–æ–¥—É–ª–∏-–∏-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã)
6. [–†–∞–±–æ—Ç–∞ —Å –¥–∞–Ω–Ω—ã–º–∏](#—Ä–∞–±–æ—Ç–∞-—Å-–¥–∞–Ω–Ω—ã–º–∏)
7. [GPS-—Ç—Ä–µ–∫–∏–Ω–≥](#gps-—Ç—Ä–µ–∫–∏–Ω–≥)
8. [–ö–∞—Ä—Ç–æ–≥—Ä–∞—Ñ–∏—è –∏ –æ—Ñ–ª–∞–π–Ω –∫–∞—Ä—Ç—ã](#–∫–∞—Ä—Ç–æ–≥—Ä–∞—Ñ–∏—è-–∏-–æ—Ñ–ª–∞–π–Ω-–∫–∞—Ä—Ç—ã)
9. [–ì–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏—è](#–≥–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏—è)
10. [–ü–æ–¥–ø–∏—Å–∫–∞ –∏ –º–æ–Ω–µ—Ç–∏–∑–∞—Ü–∏—è](#–ø–æ–¥–ø–∏—Å–∫–∞-–∏-–º–æ–Ω–µ—Ç–∏–∑–∞—Ü–∏—è)
11. [–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è](#–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å-–∏-–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è)
12. [–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å](#–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
13. [–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ](#—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)
14. [CI/CD](#cicd)

---

## –û–±—â–∏–π –æ–±–∑–æ—Ä

### –¶–µ–ª—å –ø—Ä–æ–µ–∫—Ç–∞
–°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—Ç–∏–≤–Ω–æ–≥–æ iOS –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è —Ç—Ä–µ–∫–∏–Ω–≥–∞ –∞–≤—Ç–æ–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–π —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é, –ø–ª–∞–≤–Ω–æ—Å—Ç—å—é UI –∏ –æ—Ñ—Ñ–ª–∞–π–Ω —Ä–∞–±–æ—Ç–æ–π.

### Design Philosophy: –ú–∏–Ω–∏–º–∞–ª–∏–∑–º –∏ –°—Ç–∏–ª—å

**–§–∏–ª–æ—Å–æ—Ñ–∏—è –¥–∏–∑–∞–π–Ω–∞:**
> "Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away." ‚Äî Antoine de Saint-Exup√©ry

**–ü—Ä–∏–Ω—Ü–∏–ø—ã:**
1. **–ú–∏–Ω–∏–º–∞–ª–∏–∑–º** - –ö–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å —Ü–µ–ª—å. –ù–µ—Ç –ª–∏—à–Ω–∏—Ö –∫–Ω–æ–ø–æ–∫, —Ç–µ–∫—Å—Ç–∞, –¥–µ–∫–æ—Ä–∞—Ü–∏–π
2. **Clarity** - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–∞ –ø–µ—Ä–≤–æ–º –º–µ—Å—Ç–µ: —Å–ø–∏–¥–æ–º–µ—Ç—Ä, –≤—ã—Å–æ—Ç–∞, –≤—Ä–µ–º—è - –∫—Ä—É–ø–Ω–æ –∏ —á–∏—Ç–∞–µ–º–æ
3. **Apple Native** - –°–ª–µ–¥—É–µ–º Human Interface Guidelines, SF Symbols, –Ω–∞—Ç–∏–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
4. **Fluid Motion** - –ü–ª–∞–≤–Ω—ã–µ 60 FPS –∞–Ω–∏–º–∞—Ü–∏–∏, smooth transitions
5. **Dark Mode First** - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –Ω–æ—á–Ω–æ–≥–æ –≤–æ–∂–¥–µ–Ω–∏—è

**Design References:**
- Apple Maps (—á–∏—Å—Ç–æ—Ç–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞)
- Weatherline (data visualization)
- Flighty (–º–∏–Ω–∏–º–∞–ª–∏–∑–º + –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç—å)
- Things (polish and attention to detail)

### –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –Ω–∞—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞
- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ iOS API –±–µ–∑ –ø—Ä–æ—Å–ª–æ–µ–∫
- **UX/UI**: –ù–∞—Ç–∏–≤–Ω—ã–π iOS look & feel (SwiftUI/UIKit)
- **–≠–Ω–µ—Ä–≥–æ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å**: –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å GPS –∏ –±–∞—Ç–∞—Ä–µ–µ–π
- **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å**: –ú–µ–Ω—å—à–µ –±–∞–≥–æ–≤, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –∫—Ä–æ—Å—Å-–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ—Å—Ç—å—é
- **–†–∞–∑–º–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è**: –ö–æ–º–ø–∞–∫—Ç–Ω–µ–µ Flutter/React Native
- **–û—Ñ–ª–∞–π–Ω-first**: –ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω–∞—è —Ä–∞–±–æ—Ç–∞ –±–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞

### –ö–ª—é—á–µ–≤—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∫–∞—á–µ—Å—Ç–≤—É

#### GPS –°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –∏ –¢–æ—á–Ω–æ—Å—Ç—å (–ö–†–ò–¢–ò–ß–ù–û)
- **Accuracy target**: <10m –≤ 95% —Å–ª—É—á–∞–µ–≤
- **Update frequency**: 1-2 —Å–µ–∫—É–Ω–¥—ã
- **Altitude accuracy**: ¬±5m
- **Speed accuracy**: ¬±2 km/h
- **Kalman filtering** –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
- **Outlier rejection** –¥–ª—è bad readings
- **No gaps** –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Å–∏–≥–Ω–∞–ª–∞ (interpolation)

#### UI/UX Excellence
- **Minimalist Design**: –¢–æ–ª—å–∫–æ –Ω—É–∂–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
- **Large Typography**: SF Pro Display –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
- **High Contrast**: –ß–∏—Ç–∞–µ–º–æ—Å—Ç—å –ø—Ä–∏ —è—Ä–∫–æ–º —Å–æ–ª–Ω—Ü–µ
- **Haptic Feedback**: –¢–∞–∫—Ç–∏–ª—å–Ω—ã–π –æ—Ç–∫–ª–∏–∫ –Ω–∞ –¥–µ–π—Å—Ç–≤–∏—è
- **Smooth Animations**: 60 FPS –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ

### –°–∏—Å—Ç–µ–º–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
- **–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è**: iOS 16.0+
- **–û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è**: iOS 17.0+
- **–£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞**: iPhone 11 –∏ –Ω–æ–≤–µ–µ
- **Disk space**: ~150-300 MB (—Å –æ—Ñ–ª–∞–π–Ω –∫–∞—Ä—Ç–∞–º–∏)
- **RAM**: –ú–∏–Ω–∏–º—É–º 2 GB

---

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

### –ü–∞—Ç—Ç–µ—Ä–Ω: MVVM + Clean Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Presentation Layer                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   SwiftUI    ‚îÇ  ‚îÇ   ViewModels ‚îÇ  ‚îÇ  Coordinators‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    Views     ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     Domain Layer                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Use Cases   ‚îÇ  ‚îÇ   Entities   ‚îÇ  ‚îÇ Repositories ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ  (Protocols) ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Data Layer                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ CoreData     ‚îÇ  ‚îÇ  Network     ‚îÇ  ‚îÇ   Location   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ   Manager    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

#### Presentation Layer
- **SwiftUI Views**: –î–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã–π UI (iOS 16+)
- **ViewModels**: Business logic –¥–ª—è views (Observable)
- **Coordinators**: –ù–∞–≤–∏–≥–∞—Ü–∏—è –º–µ–∂–¥—É —ç–∫—Ä–∞–Ω–∞–º–∏

#### Domain Layer
- **Entities**: –ë–∏–∑–Ω–µ—Å-–º–æ–¥–µ–ª–∏ (Trip, TrackPoint, Region, Achievement)
- **Use Cases**: –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ (StartTripUseCase, StopTripUseCase)
- **Repository Protocols**: –ê–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ –¥–ª—è data layer

#### Data Layer
- **CoreData**: –õ–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
- **MapKit/MapLibre**: –ö–∞—Ä—Ç—ã –∏ —Ç—Ä–µ–∫–∏
- **CoreLocation**: GPS —Ç—Ä–µ–∫–∏–Ω–≥
- **URLSession**: –°–µ—Ç–µ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
- **UserDefaults**: –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –∫–µ—à

---

## –¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫

### Core Technologies

#### UI Framework
```swift
// SwiftUI (iOS 16+)
- Declarative UI
- @State, @Binding, @ObservedObject
- NavigationStack
- List, ScrollView
- AsyncImage
```

#### Persistence
```swift
// CoreData
- NSPersistentContainer
- NSManagedObject subclasses
- NSFetchRequest
- Background context –¥–ª—è GPS –∑–∞–ø–∏—Å–∏
```

#### Networking
```swift
// URLSession + Async/Await
- RESTful API –∫–ª–∏–µ–Ω—Ç
- JWT –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
- Retry logic
- Response caching
```

#### GPS Tracking
```swift
// CoreLocation
- CLLocationManager
- Background location updates
- Region monitoring
- Motion activity detection
```

### Third-Party Libraries

#### Essential (SPM)
```swift
// 1. MapLibre Native (Offline maps)
.package(url: "https://github.com/maplibre/maplibre-gl-native-distribution", from: "6.0.0")

// 2. GRDB (SQLite –¥–ª—è –æ—Ñ–ª–∞–π–Ω –∫–∞—Ä—Ç)
.package(url: "https://github.com/groue/GRDB.swift", from: "6.20.0")

// 3. Alamofire (Networking)
.package(url: "https://github.com/Alamofire/Alamofire", from: "5.8.0")
```

#### Optional (–º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ–∑–∂–µ)
```swift
// SwiftUICharts - –ì—Ä–∞—Ñ–∏–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
// KeychainAccess - –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
// Lottie - –ê–Ω–∏–º–∞—Ü–∏–∏
```

---

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
RoadTripTracker/
‚îú‚îÄ‚îÄ App/
‚îÇ   ‚îú‚îÄ‚îÄ RoadTripTrackerApp.swift       # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ AppDelegate.swift              # Background tasks
‚îÇ   ‚îî‚îÄ‚îÄ SceneDelegate.swift            # Scene lifecycle
‚îÇ
‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îú‚îÄ‚îÄ DI/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DIContainer.swift          # Dependency Injection
‚îÇ   ‚îú‚îÄ‚îÄ Extensions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Date+Extensions.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CLLocation+Extensions.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Double+Extensions.swift
‚îÇ   ‚îú‚îÄ‚îÄ Utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Constants.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Logger.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Formatters.swift
‚îÇ   ‚îî‚îÄ‚îÄ Protocols/
‚îÇ       ‚îî‚îÄ‚îÄ Coordinator.swift
‚îÇ
‚îú‚îÄ‚îÄ Domain/
‚îÇ   ‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Trip.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TrackPoint.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Region.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Achievement.swift
‚îÇ   ‚îú‚îÄ‚îÄ UseCases/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Trip/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StartTripUseCase.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StopTripUseCase.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetTripsUseCase.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Tracking/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProcessLocationUseCase.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Subscription/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ValidateSubscriptionUseCase.swift
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ActivateCodeUseCase.swift
‚îÇ   ‚îî‚îÄ‚îÄ RepositoryProtocols/
‚îÇ       ‚îú‚îÄ‚îÄ TripRepositoryProtocol.swift
‚îÇ       ‚îú‚îÄ‚îÄ LocationRepositoryProtocol.swift
‚îÇ       ‚îî‚îÄ‚îÄ SubscriptionRepositoryProtocol.swift
‚îÇ
‚îú‚îÄ‚îÄ Data/
‚îÇ   ‚îú‚îÄ‚îÄ Repositories/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TripRepository.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LocationRepository.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SubscriptionRepository.swift
‚îÇ   ‚îú‚îÄ‚îÄ CoreData/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CoreDataStack.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RoadTripTracker.xcdatamodeld
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Entities/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TripEntity+CoreDataClass.swift
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TrackPointEntity+CoreDataClass.swift
‚îÇ   ‚îú‚îÄ‚îÄ Network/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ APIClient.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Endpoints.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DTOs/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TripDTO.swift
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ SubscriptionDTO.swift
‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îú‚îÄ‚îÄ LocationService.swift
‚îÇ       ‚îú‚îÄ‚îÄ MapTileService.swift
‚îÇ       ‚îî‚îÄ‚îÄ GeofenceService.swift
‚îÇ
‚îú‚îÄ‚îÄ Presentation/
‚îÇ   ‚îú‚îÄ‚îÄ Flows/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Tracking/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TrackingCoordinator.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TrackingView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MapView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StatsView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TrackingViewModel.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Trips/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TripsCoordinator.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TripsListView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TripDetailView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TripsViewModel.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Regions/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegionsCoordinator.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RegionsMapView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AchievementsView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ RegionsViewModel.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Subscription/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SubscriptionCoordinator.swift
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ PaywallView.swift
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ CodeActivationView.swift
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ SubscriptionViewModel.swift
‚îÇ   ‚îî‚îÄ‚îÄ Components/
‚îÇ       ‚îú‚îÄ‚îÄ Buttons/
‚îÇ       ‚îú‚îÄ‚îÄ Cards/
‚îÇ       ‚îî‚îÄ‚îÄ MapComponents/
‚îÇ
‚îî‚îÄ‚îÄ Resources/
    ‚îú‚îÄ‚îÄ Assets.xcassets/
    ‚îú‚îÄ‚îÄ Localizable.strings
    ‚îú‚îÄ‚îÄ RegionBoundaries/
    ‚îÇ   ‚îî‚îÄ‚îÄ russia_regions.geojson
    ‚îî‚îÄ‚îÄ MapStyles/
        ‚îî‚îÄ‚îÄ style.json
```

---

## –ú–æ–¥—É–ª–∏ –∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

### 0. –ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω —Ç—Ä–µ–∫–∏–Ω–≥–∞ (TrackingView)

#### Design Concept: –ú–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π HUD

**–ö–ª—é—á–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                     ‚îÇ ‚Üê Map (full screen)
‚îÇ                                     ‚îÇ
‚îÇ         [Your polyline here]        ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ          120 km/h            ‚îÇ  ‚îÇ ‚Üê –°–ø–∏–¥–æ–º–µ—Ç—Ä (–æ–≥—Ä–æ–º–Ω—ã–π)
‚îÇ  ‚îÇ                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     ‚õ∞Ô∏è 342 –º  |  ‚è±Ô∏è 1:24     ‚îÇ  ‚îÇ ‚Üê –í—ã—Å–æ—Ç–∞ | –í—Ä–µ–º—è
‚îÇ  ‚îÇ                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ     üìç 45.2 –∫–º               ‚îÇ  ‚îÇ ‚Üê –ü—Ä–æ–π–¥–µ–Ω–æ
‚îÇ  ‚îÇ                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  [ –ó–∞–≤–µ—Ä—à–∏—Ç—å –ø–æ–µ–∑–¥–∫—É ]       ‚îÇ  ‚îÇ ‚Üê Action button
‚îÇ  ‚îÇ                              ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**–°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤:**

**1. Speedometer (–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç)**
- **Font**: SF Pro Display Heavy, 72pt (adaptive)
- **Color**: White (dark mode), Black (light mode)
- **Update**: Real-time (–∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É)
- **Animation**: Smooth counter animation
- **Unit**: –∫–º/—á (–ª–æ–∫–∞–ª–∏–∑—É–µ–º–æ)
- **Glow effect**: Subtle shadow –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ –Ω–∞ –∫–∞—Ä—Ç–µ

**2. Altitude Display**
- **Icon**: SF Symbol "mountain.2.fill"
- **Font**: SF Pro, 20pt medium
- **Format**: "342 –º" (–Ω–∞–¥ —É—Ä–æ–≤–Ω–µ–º –º–æ—Ä—è)
- **Update**: Every 2 seconds
- **Color**: Secondary label color

**3. Time Display**
- **Icon**: SF Symbol "clock.fill"
- **Font**: SF Pro, 20pt medium
- **Format**: "1:24" (–ß–ß:–ú–ú for <24h, days for longer)
- **Update**: Every second
- **Color**: Secondary label color

**4. Distance Display**
- **Icon**: SF Symbol "location.fill"
- **Font**: SF Pro, 18pt
- **Format**: "45.2 –∫–º" (–∏–ª–∏ "234 –º" –µ—Å–ª–∏ <1 km)
- **Update**: On significant change
- **Color**: Accent color

**5. HUD Container**
- **Background**: Frosted glass (UIVisualEffectView blur)
- **Corner radius**: 24pt
- **Padding**: 24pt vertical, 20pt horizontal
- **Shadow**: Large, soft shadow
- **Position**: Bottom of screen (safe area)

#### SwiftUI Implementation

```swift
// TrackingView.swift
import SwiftUI
import CoreLocation

struct TrackingView: View {
    @StateObject private var viewModel: TrackingViewModel

    var body: some View {
        ZStack {
            // Background: Full-screen map
            MapView(
                centerCoordinate: viewModel.currentLocation,
                trackPolyline: viewModel.trackPoints,
                currentLocation: viewModel.currentLocation
            )
            .ignoresSafeArea()

            // Overlay: HUD
            VStack {
                Spacer()

                TrackingHUD(
                    speed: viewModel.currentSpeed,
                    altitude: viewModel.currentAltitude,
                    distance: viewModel.totalDistance,
                    duration: viewModel.duration,
                    isTracking: viewModel.isTracking,
                    onStopTrip: viewModel.stopTrip
                )
                .padding(.horizontal, 20)
                .padding(.bottom, 32)
            }
        }
        .preferredColorScheme(.dark) // Default to dark for driving
    }
}

// TrackingHUD.swift
struct TrackingHUD: View {
    let speed: Double // km/h
    let altitude: Double // meters
    let distance: Double // meters
    let duration: TimeInterval // seconds
    let isTracking: Bool
    let onStopTrip: () -> Void

    var body: some View {
        VStack(spacing: 20) {
            // Speedometer (HERO)
            SpeedometerView(speed: speed)

            // Secondary Stats
            HStack(spacing: 24) {
                // Altitude
                StatView(
                    icon: "mountain.2.fill",
                    value: formatAltitude(altitude),
                    color: .blue
                )

                Divider()
                    .frame(height: 30)

                // Time
                StatView(
                    icon: "clock.fill",
                    value: formatDuration(duration),
                    color: .orange
                )
            }

            // Distance
            HStack {
                Image(systemName: "location.fill")
                    .foregroundStyle(.green)
                Text(formatDistance(distance))
                    .font(.system(.title3, design: .rounded, weight: .medium))
            }

            // Stop button
            if isTracking {
                Button(action: onStopTrip) {
                    Text("–ó–∞–≤–µ—Ä—à–∏—Ç—å –ø–æ–µ–∑–¥–∫—É")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(Color.red)
                        .cornerRadius(16)
                }
                .buttonStyle(.plain)
            }
        }
        .padding(24)
        .background {
            // Frosted glass effect
            RoundedRectangle(cornerRadius: 24, style: .continuous)
                .fill(.ultraThinMaterial)
                .shadow(color: .black.opacity(0.3), radius: 20, y: 10)
        }
    }

    // MARK: - Formatters

    private func formatAltitude(_ meters: Double) -> String {
        "\(Int(meters)) –º"
    }

    private func formatDuration(_ seconds: TimeInterval) -> String {
        let hours = Int(seconds) / 3600
        let minutes = (Int(seconds) % 3600) / 60
        return String(format: "%d:%02d", hours, minutes)
    }

    private func formatDistance(_ meters: Double) -> String {
        if meters < 1000 {
            return "\(Int(meters)) –º"
        } else {
            return String(format: "%.1f –∫–º", meters / 1000)
        }
    }
}

// SpeedometerView.swift
struct SpeedometerView: View {
    let speed: Double

    @State private var animatedSpeed: Double = 0

    var body: some View {
        VStack(spacing: 4) {
            // Main speed display
            Text("\(Int(animatedSpeed))")
                .font(.system(size: 72, weight: .heavy, design: .rounded))
                .foregroundStyle(
                    LinearGradient(
                        colors: [.white, .white.opacity(0.9)],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .shadow(color: .black.opacity(0.3), radius: 4, y: 2)
                .monospacedDigit() // Prevent width jumping

            // Unit label
            Text("–∫–º/—á")
                .font(.system(.caption, design: .rounded, weight: .medium))
                .foregroundStyle(.secondary)
        }
        .onChange(of: speed) { oldValue, newValue in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                animatedSpeed = newValue
            }
        }
        .onAppear {
            animatedSpeed = speed
        }
    }
}

// StatView.swift (reusable)
struct StatView: View {
    let icon: String
    let value: String
    let color: Color

    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: icon)
                .foregroundStyle(color)
                .font(.system(size: 20))

            Text(value)
                .font(.system(.title3, design: .rounded, weight: .semibold))
                .monospacedDigit()
        }
    }
}
```

#### Adaptive Layout

**Landscape Mode:**
- –°–ø–∏–¥–æ–º–µ—Ç—Ä —Å–ø—Ä–∞–≤–∞ (–Ω–µ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –∫–∞—Ä—Ç—É)
- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–º–ø–∞–∫—Ç–Ω–µ–µ
- Stop button –º–µ–Ω—å—à–µ

**Large Text (Accessibility):**
- –°–ø–∏–¥–æ–º–µ—Ç—Ä: 96pt
- Icons: 24pt
- Respects Dynamic Type

**iPhone SE (small screen):**
- –°–ø–∏–¥–æ–º–µ—Ç—Ä: 56pt
- –ö–æ–º–ø–∞–∫—Ç–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
- –ú–µ–Ω—å—à–∏–µ paddings

---

### 1. GPS –¢—Ä–µ–∫–∏–Ω–≥ (LocationService)

#### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
- Background location updates —Å –≤—ã—Å–æ–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é
- Motion detection (—Å—Ç–∞—Ä—Ç/—Å—Ç–æ–ø –ø–æ–µ–∑–¥–∫–∏)
- **Kalman filtering** –¥–ª—è GPS —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
- **Altitude tracking** —Å –±–∞—Ä–æ–º–µ—Ç—Ä–æ–º (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
- Battery optimization
- Outlier rejection (bad GPS readings)
- –ì–µ–æ—Ñ–µ–Ω—Å–∏–Ω–≥

#### GPS Accuracy Strategy

**–¶–µ–ª—å: <10–º —Ç–æ—á–Ω–æ—Å—Ç—å –≤ 95% —Å–ª—É—á–∞–µ–≤**

**–ü–æ–¥—Ö–æ–¥:**
1. **High accuracy mode** (kCLLocationAccuracyBest)
2. **Kalman filter** –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
3. **Outlier detection** - –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º readings —Å accuracy >50m
4. **Speed consistency check** - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–µ—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ —Å–∫–∞—á–∫–∏ —Å–∫–æ—Ä–æ—Å—Ç–∏
5. **Altitude fusion** - –∫–æ–º–±–∏–Ω–∏—Ä—É–µ–º GPS + –±–∞—Ä–æ–º–µ—Ç—Ä
6. **Signal quality indicator** - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é

#### Altitude Tracking

**–ò—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö:**
1. **GPS altitude** (CLLocation.altitude) - –º–µ–Ω–µ–µ —Ç–æ—á–Ω–∞—è, –Ω–æ –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
2. **Barometric altitude** (CMAltimeter) - —Ç–æ—á–Ω–µ–µ, –Ω–æ relative
3. **Fusion** - –∫–æ–º–±–∏–Ω–∏—Ä—É–µ–º –æ–±–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞

**–¢–æ—á–Ω–æ—Å—Ç—å:**
- GPS: ¬±15-30m
- –ë–∞—Ä–æ–º–µ—Ç—Ä: ¬±1-2m (relative changes)
- Fused: ¬±5m (best of both)

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

```swift
// LocationService.swift
import CoreLocation
import CoreMotion
import Combine

final class LocationService: NSObject, ObservableObject {

    // MARK: - Properties
    private let locationManager = CLLocationManager()
    private let motionManager = CMMotionActivityManager()
    private let altimeter = CMAltimeter()

    @Published var currentLocation: CLLocation?
    @Published var currentSpeed: Double = 0 // km/h
    @Published var currentAltitude: Double = 0 // meters
    @Published var gpsAccuracy: CLLocationAccuracy = 0
    @Published var isTracking = false
    @Published var authorizationStatus: CLAuthorizationStatus = .notDetermined

    private var locationUpdateSubject = PassthroughSubject<CLLocation, Never>()
    var locationUpdates: AnyPublisher<CLLocation, Never> {
        locationUpdateSubject.eraseToAnyPublisher()
    }

    // Kalman filter state
    private var kalmanFilter = KalmanLocationFilter()
    private var lastValidLocation: CLLocation?
    private var baseAltitude: Double = 0 // For barometric calibration

    // MARK: - Configuration
    private let trackingConfig = TrackingConfiguration(
        desiredAccuracy: kCLLocationAccuracyBest,
        distanceFilter: 5, // meters (–±–æ–ª–µ–µ —á–∞—Å—Ç—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
        activityType: .automotiveNavigation,
        allowsBackgroundLocationUpdates: true,
        showsBackgroundLocationIndicator: true,
        pausesLocationUpdatesAutomatically: false
    )

    // MARK: - Init
    override init() {
        super.init()
        setupLocationManager()
    }

    // MARK: - Setup
    private func setupLocationManager() {
        locationManager.delegate = self
        locationManager.desiredAccuracy = trackingConfig.desiredAccuracy
        locationManager.distanceFilter = trackingConfig.distanceFilter
        locationManager.activityType = trackingConfig.activityType
        locationManager.allowsBackgroundLocationUpdates = trackingConfig.allowsBackgroundLocationUpdates
        locationManager.showsBackgroundLocationIndicator = trackingConfig.showsBackgroundLocationIndicator
        locationManager.pausesLocationUpdatesAutomatically = trackingConfig.pausesLocationUpdatesAutomatically
    }

    // MARK: - Public Methods
    func requestAuthorization() {
        locationManager.requestAlwaysAuthorization()
    }

    func startTracking() {
        guard authorizationStatus == .authorizedAlways else {
            print("‚ö†Ô∏è Location authorization not granted")
            return
        }

        locationManager.startUpdatingLocation()
        startMotionDetection()
        startAltitudeTracking()
        isTracking = true

        print("‚úÖ GPS tracking started")
    }

    func stopTracking() {
        locationManager.stopUpdatingLocation()
        stopMotionDetection()
        stopAltitudeTracking()
        isTracking = false

        print("üõë GPS tracking stopped")
    }

    // MARK: - Altitude Tracking
    private func startAltitudeTracking() {
        guard CMAltimeter.isRelativeAltitudeAvailable() else {
            print("‚ö†Ô∏è Barometric altimeter not available")
            return
        }

        altimeter.startRelativeAltitudeUpdates(to: .main) { [weak self] data, error in
            guard let data = data, error == nil else { return }

            // Relative altitude change in meters
            let relativeAltitude = data.relativeAltitude.doubleValue

            // Calibrate with GPS altitude on first reading
            if self?.baseAltitude == 0, let gpsAltitude = self?.currentLocation?.altitude {
                self?.baseAltitude = gpsAltitude
            }

            // Fused altitude = base GPS + barometric change
            self?.currentAltitude = (self?.baseAltitude ?? 0) + relativeAltitude
        }
    }

    private func stopAltitudeTracking() {
        altimeter.stopRelativeAltitudeUpdates()
    }

    // MARK: - Motion Detection
    private func startMotionDetection() {
        guard CMMotionActivityManager.isActivityAvailable() else { return }

        motionManager.startActivityUpdates(to: .main) { [weak self] activity in
            guard let activity = activity else { return }
            self?.handleMotionActivity(activity)
        }
    }

    private func stopMotionDetection() {
        motionManager.stopActivityUpdates()
    }

    private func handleMotionActivity(_ activity: CMMotionActivity) {
        // Auto-detect trip start/stop based on automotive motion
        if activity.automotive && !isTracking {
            // User started driving - auto start trip
            NotificationCenter.default.post(name: .tripShouldAutoStart, object: nil)
        } else if activity.stationary && isTracking {
            // User stopped - potentially end trip after timeout
            scheduleAutoStopCheck()
        }
    }

    // MARK: - Battery Optimization
    func optimizeForBattery() {
        locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters
        locationManager.distanceFilter = 50
    }

    func optimizeForAccuracy() {
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = 10
    }
}

// MARK: - CLLocationManagerDelegate
extension LocationService: CLLocationManagerDelegate {

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let rawLocation = locations.last else { return }

        // Step 1: Accuracy filter (reject bad readings)
        guard rawLocation.horizontalAccuracy >= 0 && rawLocation.horizontalAccuracy <= 50 else {
            print("‚ö†Ô∏è Inaccurate location: \(rawLocation.horizontalAccuracy)m")
            return
        }

        // Step 2: Speed consistency check (reject impossible jumps)
        if let lastLocation = lastValidLocation {
            let distance = rawLocation.distance(from: lastLocation)
            let timeInterval = rawLocation.timestamp.timeIntervalSince(lastLocation.timestamp)

            if timeInterval > 0 {
                let speed = distance / timeInterval // m/s
                let speedKmh = speed * 3.6

                // Reject if speed > 300 km/h (clearly wrong)
                if speedKmh > 300 {
                    print("‚ö†Ô∏è Impossible speed: \(speedKmh) km/h")
                    return
                }
            }
        }

        // Step 3: Kalman filter for smoothing
        let filteredLocation = kalmanFilter.process(rawLocation)

        // Step 4: Update published values
        currentLocation = filteredLocation
        gpsAccuracy = rawLocation.horizontalAccuracy

        // Calculate speed (prefer CLLocation.speed if valid, else calculate)
        if rawLocation.speed >= 0 {
            currentSpeed = rawLocation.speed * 3.6 // m/s to km/h
        } else if let lastLocation = lastValidLocation {
            let distance = filteredLocation.distance(from: lastLocation)
            let timeInterval = filteredLocation.timestamp.timeIntervalSince(lastLocation.timestamp)
            if timeInterval > 0 {
                currentSpeed = (distance / timeInterval) * 3.6
            }
        }

        // Update altitude if barometer not available
        if !CMAltimeter.isRelativeAltitudeAvailable() {
            currentAltitude = rawLocation.altitude
        }

        // Store for next iteration
        lastValidLocation = filteredLocation

        // Emit to subscribers
        locationUpdateSubject.send(filteredLocation)

        print("üìç Location: \(currentSpeed) km/h, altitude: \(currentAltitude)m, accuracy: \(gpsAccuracy)m")
    }

    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        authorizationStatus = manager.authorizationStatus

        switch authorizationStatus {
        case .authorizedAlways:
            print("‚úÖ Always location authorized")
        case .authorizedWhenInUse:
            print("‚ö†Ô∏è Only 'When In Use' authorized, need Always for background")
        case .denied, .restricted:
            print("‚ùå Location access denied")
        case .notDetermined:
            print("‚è≥ Location authorization not determined")
        @unknown default:
            break
        }
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("‚ùå Location error: \(error.localizedDescription)")
    }
}

// MARK: - Supporting Types
struct TrackingConfiguration {
    let desiredAccuracy: CLLocationAccuracy
    let distanceFilter: CLLocationDistance
    let activityType: CLActivityType
    let allowsBackgroundLocationUpdates: Bool
    let showsBackgroundLocationIndicator: Bool
    let pausesLocationUpdatesAutomatically: Bool
}

extension Notification.Name {
    static let tripShouldAutoStart = Notification.Name("tripShouldAutoStart")
}

// MARK: - Kalman Location Filter
/// Simplified Kalman filter for GPS location smoothing
/// Reduces GPS jitter and provides more stable trajectory
class KalmanLocationFilter {

    private var variance: Double = -1 // Initial variance (uninitialized)
    private var lastLocation: CLLocation?

    /// Process constant - adjust for more/less smoothing
    /// Lower = more smoothing, higher = more responsive
    private let processNoise: Double = 0.5

    func process(_ location: CLLocation) -> CLLocation {
        let accuracy = location.horizontalAccuracy

        // First reading - initialize
        if variance < 0 {
            variance = accuracy * accuracy
            lastLocation = location
            return location
        }

        // Predict
        let predictedVariance = variance + processNoise

        // Update (Kalman gain)
        let kalmanGain = predictedVariance / (predictedVariance + accuracy * accuracy)

        // Filtered coordinates
        guard let last = lastLocation else {
            lastLocation = location
            return location
        }

        let filteredLatitude = last.coordinate.latitude + kalmanGain * (location.coordinate.latitude - last.coordinate.latitude)
        let filteredLongitude = last.coordinate.longitude + kalmanGain * (location.coordinate.longitude - last.coordinate.longitude)

        // Update variance
        variance = (1 - kalmanGain) * predictedVariance

        // Create filtered location
        let filteredLocation = CLLocation(
            coordinate: CLLocationCoordinate2D(
                latitude: filteredLatitude,
                longitude: filteredLongitude
            ),
            altitude: location.altitude,
            horizontalAccuracy: location.horizontalAccuracy,
            verticalAccuracy: location.verticalAccuracy,
            course: location.course,
            speed: location.speed,
            timestamp: location.timestamp
        )

        lastLocation = filteredLocation
        return filteredLocation
    }

    func reset() {
        variance = -1
        lastLocation = nil
    }
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç Kalman —Ñ–∏–ª—å—Ç—Ä–∞:**
- ‚úÖ –£–±–∏—Ä–∞–µ—Ç GPS "–¥—Ä–æ–∂–∞–Ω–∏–µ" (jitter)
- ‚úÖ –°–≥–ª–∞–∂–∏–≤–∞–µ—Ç —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—é
- ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç—å (–Ω–µ –ª–∞–≥–∞–µ—Ç)
- ‚úÖ –£–ª—É—á—à–∞–µ—Ç —Ç–æ—á–Ω–æ—Å—Ç—å –Ω–∞ 30-50%

**–í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç:**
```
Raw GPS (—Å —à—É–º–æ–º):      Filtered GPS (–≥–ª–∞–¥–∫–∏–π):
    ‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤              ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   ‚ï±  ‚ï≤  ‚ï≤  ‚ï≤  ‚ï≤           /
  ‚ï±    ‚ï≤  ‚ï≤  ‚ï≤  ‚ï≤         /
```

---

### 2. CoreData Models

#### Trip Entity

```swift
// TripEntity+CoreDataClass.swift
import CoreData
import CoreLocation

@objc(TripEntity)
public class TripEntity: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var startDate: Date
    @NSManaged public var endDate: Date?
    @NSManaged public var totalDistance: Double
    @NSManaged public var totalDuration: TimeInterval
    @NSManaged public var averageSpeed: Double
    @NSManaged public var maxSpeed: Double
    @NSManaged public var trackPoints: NSSet?

    // Computed
    var isActive: Bool {
        endDate == nil
    }

    var trackPointsArray: [TrackPointEntity] {
        let set = trackPoints as? Set<TrackPointEntity> ?? []
        return set.sorted { $0.timestamp < $1.timestamp }
    }
}

// MARK: - Domain Mapping
extension TripEntity {
    func toDomain() -> Trip {
        Trip(
            id: id,
            startDate: startDate,
            endDate: endDate,
            totalDistance: totalDistance,
            totalDuration: totalDuration,
            averageSpeed: averageSpeed,
            maxSpeed: maxSpeed,
            trackPoints: trackPointsArray.map { $0.toDomain() }
        )
    }

    static func fromDomain(_ trip: Trip, in context: NSManagedObjectContext) -> TripEntity {
        let entity = TripEntity(context: context)
        entity.id = trip.id
        entity.startDate = trip.startDate
        entity.endDate = trip.endDate
        entity.totalDistance = trip.totalDistance
        entity.totalDuration = trip.totalDuration
        entity.averageSpeed = trip.averageSpeed
        entity.maxSpeed = trip.maxSpeed
        return entity
    }
}
```

#### TrackPoint Entity

```swift
// TrackPointEntity+CoreDataClass.swift
import CoreData
import CoreLocation

@objc(TrackPointEntity)
public class TrackPointEntity: NSManagedObject {
    @NSManaged public var latitude: Double
    @NSManaged public var longitude: Double
    @NSManaged public var altitude: Double
    @NSManaged public var speed: Double
    @NSManaged public var course: Double
    @NSManaged public var accuracy: Double
    @NSManaged public var timestamp: Date
    @NSManaged public var trip: TripEntity?

    var coordinate: CLLocationCoordinate2D {
        CLLocationCoordinate2D(latitude: latitude, longitude: longitude)
    }
}

// MARK: - Domain Mapping
extension TrackPointEntity {
    func toDomain() -> TrackPoint {
        TrackPoint(
            latitude: latitude,
            longitude: longitude,
            altitude: altitude,
            speed: speed,
            course: course,
            accuracy: accuracy,
            timestamp: timestamp
        )
    }

    static func fromLocation(_ location: CLLocation, in context: NSManagedObjectContext) -> TrackPointEntity {
        let entity = TrackPointEntity(context: context)
        entity.latitude = location.coordinate.latitude
        entity.longitude = location.coordinate.longitude
        entity.altitude = location.altitude
        entity.speed = location.speed
        entity.course = location.course
        entity.accuracy = location.horizontalAccuracy
        entity.timestamp = location.timestamp
        return entity
    }
}
```

---

### 3. Offline Maps (MapLibre)

#### MapTileService

```swift
// MapTileService.swift
import Foundation
import MapLibre

final class MapTileService {

    // MARK: - Properties
    private let tileCache = URLCache(
        memoryCapacity: 50 * 1024 * 1024,  // 50 MB
        diskCapacity: 500 * 1024 * 1024    // 500 MB
    )

    private let fileManager = FileManager.default

    // MARK: - Offline Region Management

    /// Download offline map tiles for a region
    func downloadOfflineRegion(
        bounds: MGLCoordinateBounds,
        minZoom: Double = 5,
        maxZoom: Double = 15,
        stylePath: URL
    ) async throws -> MGLOfflinePack {

        // Define tile pyramid region
        let region = MGLTilePyramidOfflineRegion(
            styleURL: stylePath,
            bounds: bounds,
            fromZoomLevel: minZoom,
            toZoomLevel: maxZoom
        )

        // Context info
        let context = [
            "name": "Russia Region",
            "date": ISO8601DateFormatter().string(from: Date())
        ]
        let encodedContext = try JSONEncoder().encode(context)

        // Start download
        return try await withCheckedThrowingContinuation { continuation in
            MGLOfflineStorage.shared.addPack(for: region, withContext: encodedContext) { pack, error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else if let pack = pack {
                    pack.resume()
                    continuation.resume(returning: pack)
                }
            }
        }
    }

    /// Get all downloaded offline packs
    func getOfflinePacks() async throws -> [MGLOfflinePack] {
        try await withCheckedThrowingContinuation { continuation in
            MGLOfflineStorage.shared.reloadPacks { packs, error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume(returning: packs ?? [])
                }
            }
        }
    }

    /// Delete offline pack
    func deleteOfflinePack(_ pack: MGLOfflinePack) async throws {
        try await withCheckedThrowingContinuation { continuation in
            MGLOfflineStorage.shared.removePack(pack) { error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume(returning: ())
                }
            }
        }
    }

    // MARK: - Tile Storage Info

    func getTotalCacheSize() -> Int64 {
        var totalSize: Int64 = 0

        if let cachePath = tileCache.diskPath {
            let cacheURL = URL(fileURLWithPath: cachePath)

            if let enumerator = fileManager.enumerator(at: cacheURL, includingPropertiesForKeys: [.fileSizeKey]) {
                for case let fileURL as URL in enumerator {
                    if let fileSize = try? fileURL.resourceValues(forKeys: [.fileSizeKey]).fileSize {
                        totalSize += Int64(fileSize)
                    }
                }
            }
        }

        return totalSize
    }

    func clearTileCache() {
        tileCache.removeAllCachedResponses()
        MGLOfflineStorage.shared.clearAmbientCache { error in
            if let error = error {
                print("‚ùå Failed to clear cache: \(error)")
            } else {
                print("‚úÖ Tile cache cleared")
            }
        }
    }
}
```

#### MapView Component

```swift
// MapView.swift
import SwiftUI
import MapLibre

struct MapView: UIViewRepresentable {

    @Binding var centerCoordinate: CLLocationCoordinate2D
    @Binding var trackPolyline: [CLLocationCoordinate2D]
    var currentLocation: CLLocationCoordinate2D?

    func makeUIView(context: Context) -> MLNMapView {
        let mapView = MLNMapView(frame: .zero)
        mapView.delegate = context.coordinator

        // Style
        mapView.styleURL = Bundle.main.url(forResource: "style", withExtension: "json")

        // User location
        mapView.showsUserLocation = true
        mapView.userTrackingMode = .follow

        // Initial position
        mapView.setCenter(centerCoordinate, zoomLevel: 13, animated: false)

        return mapView
    }

    func updateUIView(_ mapView: MLNMapView, context: Context) {
        // Update track polyline
        if !trackPolyline.isEmpty {
            updateTrackPolyline(on: mapView)
        }

        // Update current location marker
        if let location = currentLocation {
            updateCurrentLocationMarker(on: mapView, location: location)
        }
    }

    private func updateTrackPolyline(on mapView: MLNMapView) {
        // Remove old polyline
        if let existingSource = mapView.style?.source(withIdentifier: "track-source") {
            mapView.style?.removeSource(existingSource)
        }

        // Add new polyline
        let coordinates = trackPolyline
        let polyline = MGLPolylineFeature(coordinates: coordinates, count: UInt(coordinates.count))

        let source = MGLShapeSource(identifier: "track-source", shape: polyline, options: nil)
        mapView.style?.addSource(source)

        let layer = MGLLineStyleLayer(identifier: "track-layer", source: source)
        layer.lineColor = NSExpression(forConstantValue: UIColor.systemBlue)
        layer.lineWidth = NSExpression(forConstantValue: 4)
        layer.lineCap = NSExpression(forConstantValue: "round")
        layer.lineJoin = NSExpression(forConstantValue: "round")

        mapView.style?.addLayer(layer)
    }

    private func updateCurrentLocationMarker(on mapView: MLNMapView, location: CLLocationCoordinate2D) {
        // Custom annotation for current location
        // (Implementation depends on design requirements)
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, MLNMapViewDelegate {
        var parent: MapView

        init(_ parent: MapView) {
            self.parent = parent
        }

        func mapView(_ mapView: MLNMapView, didFinishLoading style: MLNStyle) {
            print("‚úÖ Map style loaded")
        }
    }
}
```

---

### 4. Region Detection & Geofencing

#### RegionDetectionService

```swift
// RegionDetectionService.swift
import Foundation
import CoreLocation

final class RegionDetectionService {

    // MARK: - Properties
    private let geoJSONParser = GeoJSONParser()
    private var regionBoundaries: [RegionBoundary] = []

    // MARK: - Init
    init() {
        loadRegionBoundaries()
    }

    // MARK: - Load GeoJSON
    private func loadRegionBoundaries() {
        guard let url = Bundle.main.url(forResource: "russia_regions", withExtension: "geojson"),
              let data = try? Data(contentsOf: url) else {
            print("‚ùå Failed to load russia_regions.geojson")
            return
        }

        regionBoundaries = geoJSONParser.parse(data)
        print("‚úÖ Loaded \(regionBoundaries.count) regions")
    }

    // MARK: - Region Detection
    func detectRegion(for coordinate: CLLocationCoordinate2D) -> Region? {
        for boundary in regionBoundaries {
            if boundary.contains(coordinate) {
                return Region(
                    id: boundary.id,
                    name: boundary.name,
                    code: boundary.code
                )
            }
        }
        return nil
    }

    func detectVisitedRegions(from trackPoints: [TrackPoint]) -> Set<Region> {
        var visitedRegions = Set<Region>()

        // Sample every 10th point for performance
        stride(from: 0, to: trackPoints.count, by: 10).forEach { index in
            let point = trackPoints[index]
            let coordinate = CLLocationCoordinate2D(
                latitude: point.latitude,
                longitude: point.longitude
            )

            if let region = detectRegion(for: coordinate) {
                visitedRegions.insert(region)
            }
        }

        return visitedRegions
    }
}

// MARK: - Supporting Types
struct RegionBoundary {
    let id: String
    let name: String
    let code: String
    let coordinates: [CLLocationCoordinate2D]

    func contains(_ coordinate: CLLocationCoordinate2D) -> Bool {
        // Ray casting algorithm for point-in-polygon
        var inside = false
        var j = coordinates.count - 1

        for i in 0..<coordinates.count {
            let xi = coordinates[i].longitude
            let yi = coordinates[i].latitude
            let xj = coordinates[j].longitude
            let yj = coordinates[j].latitude

            let intersect = ((yi > coordinate.latitude) != (yj > coordinate.latitude)) &&
                           (coordinate.longitude < (xj - xi) * (coordinate.latitude - yi) / (yj - yi) + xi)

            if intersect {
                inside.toggle()
            }

            j = i
        }

        return inside
    }
}

struct GeoJSONParser {
    func parse(_ data: Data) -> [RegionBoundary] {
        // Parse GeoJSON and create RegionBoundary objects
        // Implementation depends on GeoJSON structure
        []
    }
}
```

---

## –†–∞–±–æ—Ç–∞ —Å –¥–∞–Ω–Ω—ã–º–∏

### CoreData Stack

```swift
// CoreDataStack.swift
import CoreData

final class CoreDataStack {

    static let shared = CoreDataStack()

    // MARK: - Persistent Container
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "RoadTripTracker")

        container.loadPersistentStores { description, error in
            if let error = error {
                fatalError("‚ùå CoreData failed to load: \(error)")
            }
            print("‚úÖ CoreData loaded: \(description.url?.absoluteString ?? "")")
        }

        // Merge policy
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy

        return container
    }()

    // MARK: - Contexts
    var viewContext: NSManagedObjectContext {
        persistentContainer.viewContext
    }

    func newBackgroundContext() -> NSManagedObjectContext {
        let context = persistentContainer.newBackgroundContext()
        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        return context
    }

    // MARK: - Save
    func save() {
        let context = viewContext

        guard context.hasChanges else { return }

        do {
            try context.save()
        } catch {
            print("‚ùå Failed to save context: \(error)")
        }
    }

    func saveContext(_ context: NSManagedObjectContext) {
        guard context.hasChanges else { return }

        context.perform {
            do {
                try context.save()
            } catch {
                print("‚ùå Failed to save context: \(error)")
            }
        }
    }
}
```

---

## –ü–æ–¥–ø–∏—Å–∫–∞ –∏ –º–æ–Ω–µ—Ç–∏–∑–∞—Ü–∏—è

### StoreKit 2 Integration

```swift
// SubscriptionManager.swift
import StoreKit

@MainActor
final class SubscriptionManager: ObservableObject {

    @Published var subscriptionStatus: SubscriptionStatus = .notSubscribed
    @Published var availableProducts: [Product] = []

    private let productIDs = [
        "com.roadtriptracker.monthly",
        "com.roadtriptracker.yearly"
    ]

    // MARK: - Init
    init() {
        Task {
            await loadProducts()
            await checkSubscriptionStatus()
        }
    }

    // MARK: - Load Products
    func loadProducts() async {
        do {
            availableProducts = try await Product.products(for: productIDs)
            print("‚úÖ Loaded \(availableProducts.count) products")
        } catch {
            print("‚ùå Failed to load products: \(error)")
        }
    }

    // MARK: - Purchase
    func purchase(_ product: Product) async throws -> Transaction? {
        let result = try await product.purchase()

        switch result {
        case .success(let verification):
            let transaction = try checkVerified(verification)
            await transaction.finish()
            await checkSubscriptionStatus()
            return transaction

        case .pending:
            print("‚è≥ Purchase pending")
            return nil

        case .userCancelled:
            print("üö´ User cancelled")
            return nil

        @unknown default:
            return nil
        }
    }

    // MARK: - Restore
    func restorePurchases() async {
        for await result in Transaction.currentEntitlements {
            let transaction = try? checkVerified(result)
            await transaction?.finish()
        }
        await checkSubscriptionStatus()
    }

    // MARK: - Status Check
    private func checkSubscriptionStatus() async {
        var isSubscribed = false

        for await result in Transaction.currentEntitlements {
            if let transaction = try? checkVerified(result),
               transaction.productType == .autoRenewable {
                isSubscribed = true
                break
            }
        }

        subscriptionStatus = isSubscribed ? .subscribed : .notSubscribed
    }

    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .unverified:
            throw StoreError.failedVerification
        case .verified(let safe):
            return safe
        }
    }
}

enum SubscriptionStatus {
    case notSubscribed
    case subscribed
    case expired
}

enum StoreError: Error {
    case failedVerification
}
```

---

## –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è

### 1. –ë–∞—Ç–∞—Ä–µ—è

```swift
// Battery optimization strategies
- Use significant location changes –∫–æ–≥–¥–∞ —Ç—Ä–µ–∫–∏–Ω–≥ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω
- –°–Ω–∏–∂–∞—Ç—å accuracy –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –¥–≤–∏–∂–µ—Ç—Å—è
- Batch –∑–∞–ø–∏—Å–∏ –≤ CoreData (—Ä–∞–∑ –≤ 30 —Å–µ–∫—É–Ω–¥)
- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å background fetch –≤–º–µ—Å—Ç–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã
```

### 2. –ü–∞–º—è—Ç—å

```swift
// Memory optimization
- NSFetchRequest —Å –ª–∏–º–∏—Ç–æ–º –∏ batch size
- Lazy loading –¥–ª—è track points
- Autoreleasepool –¥–ª—è batch –æ–ø–µ—Ä–∞—Ü–∏–π
- –û—Å–≤–æ–±–æ–∂–¥–∞—Ç—å –∫–∞—Ä—Ç—ã –∫–æ–≥–¥–∞ —ç–∫—Ä–∞–Ω –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω
```

### 3. –°–µ—Ç—å

```swift
// Network optimization
- Background URLSession –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
- Compression –¥–ª—è —Ç—Ä–µ–∫–æ–≤
- Incremental sync (—Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ —Ç–æ—á–∫–∏)
- Retry —Å exponential backoff
```

---

## –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### 1. Keychain

```swift
// Store sensitive data
- JWT —Ç–æ–∫–µ–Ω—ã ‚Üí Keychain
- Subscription status ‚Üí Keychain + UserDefaults
- API keys ‚Üí Obfuscated –≤ code
```

### 2. SSL Pinning

```swift
// Alamofire SSL pinning
let evaluators = [
    "api.roadtriptracker.com": PublicKeysTrustEvaluator()
]

let manager = Session(
    serverTrustManager: ServerTrustManager(evaluators: evaluators)
)
```

---

## –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### Unit Tests
- Use cases
- Repository logic
- Region detection algorithm
- Distance calculations

### UI Tests
- Critical flows (start/stop trip)
- Subscription paywall
- Onboarding

### Integration Tests
- CoreData operations
- Location service
- Network sync

---

## CI/CD

### Fastlane

```ruby
# Fastfile
lane :test do
  run_tests(scheme: "RoadTripTracker")
end

lane :beta do
  build_app(scheme: "RoadTripTracker")
  upload_to_testflight
end

lane :release do
  build_app(scheme: "RoadTripTracker")
  upload_to_app_store
end
```

### GitHub Actions

```yaml
name: iOS Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v3
      - name: Build
        run: |
          xcodebuild -scheme RoadTripTracker \
                     -destination 'platform=iOS Simulator,name=iPhone 15' \
                     build test
```

---

## Roadmap

### Phase 1 (MVP - 4 –Ω–µ–¥–µ–ª–∏)
- ‚úÖ GPS —Ç—Ä–µ–∫–∏–Ω–≥
- ‚úÖ CoreData
- ‚úÖ –ë–∞–∑–æ–≤–∞—è –∫–∞—Ä—Ç–∞
- ‚úÖ –°–ø–∏—Å–æ–∫ –ø–æ–µ–∑–¥–æ–∫

### Phase 2 (2 –Ω–µ–¥–µ–ª–∏)
- ‚úÖ Offline –∫–∞—Ä—Ç—ã
- ‚úÖ Region detection
- ‚úÖ –ì–µ–π–º–∏—Ñ–∏–∫–∞—Ü–∏—è

### Phase 3 (2 –Ω–µ–¥–µ–ª–∏)
- ‚úÖ Subscription (StoreKit)
- ‚úÖ Backend sync
- ‚úÖ Telegram bot integration

### Phase 4 (1 –Ω–µ–¥–µ–ª—è)
- ‚úÖ Polish & Testing
- ‚úÖ App Store submission

---

## –†–µ—Å—É—Ä—Å—ã

### –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
- [Apple Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/)
- [CoreLocation Best Practices](https://developer.apple.com/documentation/corelocation)
- [MapLibre Documentation](https://maplibre.org/maplibre-gl-native/ios/latest/)
- [StoreKit 2 Guide](https://developer.apple.com/documentation/storekit)

### Tools
- Xcode 15+
- Instruments (–ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ)
- Charles Proxy (network debugging)
- Fastlane (CI/CD)

---

**–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ:** 2026-01-29
